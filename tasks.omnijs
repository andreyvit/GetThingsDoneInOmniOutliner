/*{
	"type": "action",
	"targets": ["omnioutliner"],
	"author": "Andrey Tarantsov",
	"identifier": "com.tarantsov.automation.omniTasks",
	"version": "1.0",
	"description": "GTD done right",
	"label": "GTD",
	"shortLabel": "GTD"
}*/
var _ = function(){
    const config = {
        // start days at 4am
        startOfDayHour: 4
    }

    const timeframes = {
        'unspecified': {
            isCommitted: false,
            isSchedulingCovered: false,
        },
        'Today': {
            isCommitted: false,
            isSchedulingCovered: true,
            shouldDeadlineDefaultToStartDay: true,
        },
        'Day': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 1,
            reservedDays: 1,
            redDays: 2,
            criticalDays: 4,
        },
        'Days': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 2,
            reservedDays: 2,
            redDays: 3,
            criticalDays: 5,
        },
        'Week': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 7,
            reservedDays: 2,
            redDays: 14,
            criticalDays: 21,
        },
        'Month': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 30,
            reservedDays: 5,
            redDays: 60,
            criticalDays: 90,
        },
        'Quarter': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 30 * 3,
            reservedDays: 30,
            redDays: 30 * 5,
            criticalDays: 30 * 7,
        },
        'Year': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 365,
            reservedDays: 30 * 2,
            redDays: Math.floor(365 * 1.5),
            criticalDays: Math.floor(365 * 2),
        },
    }

    const behaviors = {
        'default': {
            name: 'default',
        },
        'root': {
            name: 'root',
            isContainer: true,
        },
        'Area': {
            name: 'Area',
            isContainer: true,
        },
        'backlog': {
            name: 'backlog',
            isContainer: true,
            shouldBeCollapsed: true,
        },
        'Inbox': {
            name: 'Inbox',
            isContainer: true,
        },
        'Idea': {
            name: 'Idea',
            isSchedulingCovered: true,
        },
        'Blocked': {
            name: 'Blocked',
            isSchedulingCovered: true,
        },
        'Waiting For': {
            name: 'Waiting For',
            isSchedulingCovered: true,
        },
        'Folder': {
            name: 'Folder',
            isContainer: false,
            isStyledAsFolder: true,
        },
        'Elephant': {
            name: 'Elephant',
            isContainer: true,
        },
    }

    const modes = {
        topLevel: {
            name: 'topLevel',
        },
        topLevelItem: {
            name: 'topLevelItem',
        },
        dailyItem: {
            name: 'dailyItem',
        },
        regular: {
            name: 'regular',
        },
    }

    const urgencies = {
        done: {
            name: 'done',
            isAttentionRequired: false,
            isProminencyRequired: false,
        },
        normal: {
            name: 'normal',
            isProminencyRequired: false,
            isAttentionRequired: false,
        },
        future: {
            name: 'future',
            futureStyle: true,
            isProminencyRequired: false,
            isAttentionRequired: false,
        },
        soon: {
            name: 'soon',
            isProminencyRequired: true,
            isAttentionRequired: false,
        },
        attention: {
            name: 'attention',
            attentionStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
        pastDue: {
            name: 'pastDue',
            dueStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
        critical: {
            name: 'critical',
            urgentStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
    }

    const specials = {
        backlog: {
            name: 'backlog',
        },
        daily: {
            name: 'daily',
        },
    }

    const actionWords = `
        обсудить
    `.trim().split(/\s+/)

    class Globals {
        constructor(outline, now) {
            this.outline = outline

            this.calendar = Calendar.current

            this.now = now
            this.today = this.startOfDay(this.now)
            this.tomorrow = this.startOfDay(this.addDays(this.today, 1))

            // TODO: Mon-Fri = till end of this week, Sat-Sun = till end of next week
            this.planningHorizon = this.startOfDay(this.addDays(this.today, 7))
        }

        addDays(date, n) {
            return this.calendar.dateByAddingDateComponents(date, ndays(n))
        }

        startOfDay(date) {
            let c = this.calendar.dateComponentsFromDate(date)
            c.hour = config.startOfDayHour
            c.minute = 0
            c.second = 0
            c.nanosecond = 0
            let d = this.calendar.dateFromDateComponents(c)
            if (d == null) {
                let c = new DateComponents()
                c.hours = config.startOfDayHour
                d = this.calendar.dateByAddingDateComponents(this.calendar.startOfDay(date), c)
            }
            return d
        }
    }

	const action = new PlugIn.Action(function(selection, sender){
        const document = selection.document
        const outline = document.outline

        const gs = new Globals(outline, new Date())

        const doneColumn = outline.columns.byTitle('D')
        const doneDateColumn = outline.columns.byTitle('Done')
        const typeColumn = outline.columns.byTitle('Type')
        const whenColumn = outline.columns.byTitle('When')
        const taskColumn = outline.columns.byTitle('Task')
        const deadlineColumn = outline.columns.byTitle('Deadline')
        const startColumn = outline.columns.byTitle('Start')
        const verboseColumn = outline.columns.byTitle('V')
        const reserveColumn = outline.columns.byTitle('Re')

        console.clear()
        console.log(JSON.stringify({now: gs.now, today: gs.today, tomorrow: gs.tomorrow}, null, 2))

        const folderStyle = requireNamedStyle('Heading 2')
        const urgentStyle = requireNamedStyle('Urgent')
        const attentionStyle = requireNamedStyle('Attention')
        const dueStyle = requireNamedStyle('Past Due')
        const futureStyle = requireNamedStyle('Future')
        const reviewStyle = requireNamedStyle('Review')
        const doneStyle = requireNamedStyle('Done')

        var pendingChanges = []
        var itemsToCollapse = []
        var itemsToReveal = []

        function loadItem(outlineItem) {
            let item = {
                outlineItem,

                typeColumnValue: getEnumValue(outlineItem, typeColumn),
                title: getStringValue(outlineItem, taskColumn),
                timeframeColumnValue: getEnumValue(outlineItem, whenColumn),
                isVerbose: (outlineItem.level === 0 || getCheckboxValue(outlineItem, verboseColumn)),
                isDone: getCheckboxValue(outlineItem, doneColumn),
                doneDate: outlineItem.valueForColumn(doneDateColumn),

                startDate: outlineItem.valueForColumn(startColumn),
                reservedDays: getNumericValue(outlineItem, reserveColumn),  // how much time you think this task will take
                deadline: outlineItem.valueForColumn(deadlineColumn),
                timeframe: timeframes.unspecified,
                behavior: behaviors.default,

                warnings: [],

                special: null,
            }

            if (item.title != null) {
                let title = item.title.toUpperCase()
                if (title === "BACKLOG") {
                    item.special = specials.backlog
                } else if (title === "DAILY") {
                    item.special = specials.daily
                }
            }

            if (item.timeframeColumnValue != null) {
                if (!timeframes.hasOwnProperty(item.timeframeColumnValue)) {
                    throw new Error(`unknown When ${item.timeframeColumnValue} in task: ${item.title}`)
                }
                item.timeframe = timeframes[item.timeframeColumnValue]
            }

            if (item.outlineItem.level === 0) {
                item.behavior = behaviors.root
            } else if (item.typeColumnValue != null) {
                if (!behaviors.hasOwnProperty(item.typeColumnValue)) {
                    throw new Error(`unknown Type ${item.typeColumnValue} in task: ${item.title}`)
                }
                item.behavior = behaviors[item.typeColumnValue]
            } else if (item.outlineItem.level === 1) {
                item.behavior = behaviors.Area
            } else if (item.title != null && item.title.toUpperCase() === "BACKLOG") {
                item.behavior = behaviors.backlog
            }

            return item
        }

        function processItem(item, atom, context) {
            let children = item.outlineItem.children.map(loadItem)

            let childrenContext = {...context}

            if (atom == null && !item.behavior.isContainer) {
                atom = item
            }

            // deadline
            if (context.deadline) {
                if (item.deadline) {
                    if (item.deadline > context.deadline) {
                        item.warnings.push(`item deadline is later than ancestor's deadline`)
                    }
                } else {
                    item.deadline = context.deadline
                }
            }

            // backlog
            if (item.special === specials.backlog) {
                childrenContext.isUnderBacklog = true
                childrenContext.backlogItem = item
            } else if (children.length > 0) {
                children.forEach((child) => {
                    if (child.special === specials.backlog) {
                        childrenContext.backlogItem = child
                        // console.log(`Found backlog child ${getStringValue(child, taskColumn)} under ${item.title}`)
                    }
                })
            }

            let isSchedulingCovered = context.isSchedulingCovered

            let urgency = null, targetDate = null, redDate = null, criticalDate = null

            if (item.isDone) {
                urgency = urgencies.done
                isSchedulingCovered = true
            }
            if (atom != null && (item.behavior.isSchedulingCovered || item.timeframe.isSchedulingCovered)) {
                isSchedulingCovered = true
            }
            if (urgency == null && atom != null && item.startDate != null && item.startDate >= gs.tomorrow) {
                urgency = urgencies.future
                isSchedulingCovered = true
            }
            if (urgency == null && context.isUnderDailyChecklist) {
                urgency = urgencies.normal
                isSchedulingCovered = true
            }

            if (context.isUnderDailyChecklist) {
                if (item.startDate == null || item.startDate < gs.today) {
                    item.outlineItem.setValueForColumn(gs.today, startColumn)
                    item.startDate = gs.today
                }
                if (item.startDate != null && item.startDate < gs.today) {
                    resetChecked(item.outlineItem)
                }
                if (item.timeframe === timeframes.unspecified) {
                    item.timeframe = timeframes.Today
                }
            } else {
                if (item.timeframe.isCommitted && item.startDate == null) {
                    item.outlineItem.setValueForColumn(gs.today, startColumn)
                    item.startDate = gs.today
                }
            }

            if (item.timeframe.shouldDeadlineDefaultToStartDay && item.deadline == null && item.startDate != null) {
                item.deadline = gs.startOfDay(item.startDate)
            }

            if (item.startDate != null) {
                let defaultReservedDays = (item.timeframe.isCommitted ? item.timeframe.reservedDays : 2)

                if (urgency == null && item.deadline) {
                    let deadlineReservedDays = (item.reservedDays == null ? defaultReservedDays : item.reservedDays)
                    targetDate = gs.startOfDay(gs.addDays(item.deadline, -deadlineReservedDays))
                    redDate = gs.startOfDay(item.deadline)
                    criticalDate = gs.startOfDay(gs.addDays(item.deadline, 1))
                    urgency = urgencyFromDates(gs, targetDate, redDate, criticalDate)
                }
                if (urgency == null && item.timeframe.isCommitted) {
                    let dueDate = gs.startOfDay(gs.addDays(item.startDate, item.timeframe.dueDays))
                    targetDate = gs.startOfDay(gs.addDays(dueDate, -defaultReservedDays))
                    redDate = gs.startOfDay(gs.addDays(item.startDate, item.timeframe.redDays))
                    criticalDate = gs.startOfDay(gs.addDays(dueDate, item.timeframe.criticalDays))
                    urgency = urgencyFromDates(gs, targetDate, redDate, criticalDate)
                }
            }

            if (urgency == null && targetDate != null && targetDate < gs.planningHorizon) {
                urgency = urgencies.soon
            }

            if (urgency == null) {
                urgency = urgencies.normal
            }

            if (item.isDone && item.doneDate == null) {
                item.outlineItem.setValueForColumn(gs.now, doneDateColumn)
            } else if (!item.isDone && item.doneDate != null) {
                item.outlineItem.setValueForColumn(null, doneDateColumn)
            }

            let isAttentionRequiredByDescendants = false
            let isReviewRequiredByDescendants = false
            let isProminencyRequiredByDescendants = false

            // *************** CHILDREN ***************
            childrenContext.deadline = item.deadline
            childrenContext.reservedDays = item.reservedDays
            childrenContext.isSchedulingCovered = isSchedulingCovered
            if (item.special === specials.daily) {
                childrenContext.isUnderDailyChecklist = true
            }
            if (item.outlineItem.children.length > 0) {
                let isFirstChild = true
                children.forEach((child) => {
                    let isChildNonNextAction = (atom != null && !isFirstChild)
                    let rv = processItem(child, atom, childrenContext)
                    if (atom != null) {
                        if (isFirstChild && !isSchedulingCovered && rv.isSchedulingCovered) {
                            isSchedulingCovered = true
                        }
                        childrenContext.isSchedulingCovered = true
                    }
                    if (rv.isReviewRequiredInSubtree) {
                        isReviewRequiredByDescendants = true
                    }
                    if (rv.isAttentionRequiredInSubtree) {
                        isAttentionRequiredByDescendants = true
                    }
                    if (rv.isProminencyRequiredInSubtree) {
                        isProminencyRequiredByDescendants = true
                    }
                    isFirstChild = false
                })
            }

            let isReviewRequired = false
            if (atom != null && !isSchedulingCovered) {
                isReviewRequired = true
            }

            let isAttentionRequired = (isReviewRequired || urgency.isAttentionRequired)
            let isAttentionRequiredInSubtree = isAttentionRequired || isAttentionRequiredByDescendants
            let isProminencyRequired = (urgency.isProminencyRequired || isAttentionRequiredInSubtree)

            let isReviewRequiredInSubtree = isReviewRequired || isReviewRequiredByDescendants

            let isProminencyRequiredInSubtree = isProminencyRequired || isProminencyRequiredByDescendants

            let shouldBeCollapsed = !!item.behavior.shouldBeCollapsed

            let isMarkedAsRequiringReview = isReviewRequired || ((item === atom) && isReviewRequiredByDescendants)

            if (item === atom) {
                let shouldBeInBacklog = !isProminencyRequiredInSubtree
                if (context.backlogItem != null) {
                    if (shouldBeInBacklog && !context.isUnderBacklog) {
                        // move to backlog
                        pendingChanges.push(function() {
                            console.log(`moving to backlog: ${item.title}`)
                            outline.moveItems([item.outlineItem], context.backlogItem.outlineItem.end)
                        })
                    } else if (!shouldBeInBacklog && context.isUnderBacklog) {
                        // move out of backlog
                        pendingChanges.push(function() {
                            console.log(`moving out of backlog: ${item.title}`)
                            outline.moveItems([item.outlineItem], context.backlogItem.outlineItem.before)
                        })
                    }
                }

                shouldBeCollapsed = (shouldBeInBacklog || !isAttentionRequiredByDescendants)
            } else {
                if (atom != null) {
                    let levelInAtom = item.outlineItem.level - atom.outlineItem.level
                    shouldBeCollapsed = (levelInAtom == 1 && !isAttentionRequiredByDescendants)
                }
            }

            toggleNamedStyle(item.outlineItem, reviewStyle, isMarkedAsRequiringReview)
            toggleNamedStyle(item.outlineItem, folderStyle, item.behavior.isStyledAsFolder)
            toggleNamedStyle(item.outlineItem, doneStyle, item.isDone)
            toggleNamedStyle(item.outlineItem, futureStyle, urgency.futureStyle)
            toggleNamedStyle(item.outlineItem, attentionStyle, urgency.attentionStyle)
            toggleNamedStyle(item.outlineItem, dueStyle, urgency.dueStyle)
            toggleNamedStyle(item.outlineItem, urgentStyle, urgency.urgentStyle)

            if (isAttentionRequired) {
                itemsToReveal.push(item.outlineItem)
            } else if (shouldBeCollapsed) {
                itemsToCollapse.push(item.outlineItem)
            }

            let rv = {
                isSchedulingCovered,
                isReviewRequiredInSubtree,
                isAttentionRequiredInSubtree,
                isProminencyRequiredInSubtree,
            }

            if (item.isVerbose) {
                let itemInfo = {
                    item,
                    context,
                    urgency: urgency.name, targetDate, redDate, criticalDate,
                    atom: (atom ? (atom.title || '<untitled>') : null),
                    isSchedulingCovered,
                    isReviewRequired, isReviewRequiredByDescendants, isReviewRequiredInSubtree,
                    isAttentionRequired, isAttentionRequiredByDescendants, isAttentionRequiredInSubtree,
                    isProminencyRequired, isProminencyRequiredByDescendants, isProminencyRequiredInSubtree,
                }
                console.log(JSON.stringify(itemInfo, null, 2))
                    // console.log(`title = ${item.title}, type = ${item.typeColumnValue}, mode = ${mode.name}, item.deadline = ${item.deadline}, committedAt = ${item.startDate},
                    //  urgency = ${urgency.name}, targetDate = ${targetDate}, redDate = ${redDate}, criticalDate = ${criticalDate},
                    // atom = ${atom}, isSchedulingCovered = ${isSchedulingCovered},
                    //  isReviewRequired = ${isReviewRequired}, rv = ${JSON.stringify(rv)}`)
            }

            return rv
        }

        function executeActions(outlineItem, actions) {

        }

        function resetChecked(outlineItem) {
            outlineItem.setValueForColumn(State.Unchecked, doneColumn)
        }

        function requireNamedStyle(name) {
            const style = outline.namedStyles.byName(name)
            if (style == null) {
                throw new Error("Cannot find named style " + name)
            }
            return style
        }
        function run() {
            let rootItem = loadItem(outline.rootItem)
            let rootContext = {
                isSchedulingCovered: false,
                isUnderBacklog: false,
                isUnderDailyChecklist: false,
                backlogItem: null,
            }
            processItem(rootItem, null, rootContext)

            for (let change of pendingChanges) {
                change()
            }
            for (let outlineItem of itemsToCollapse) {
                for (let editor of document.editors) {
                    let node = editor.nodeForObject(outlineItem)
                    if (node != null && node.isExpanded && node.canCollapse) {
                        node.collapse()
                    }
                }
            }
            for (let outlineItem of itemsToReveal) {
                for (let editor of document.editors) {
                    let node = editor.nodeForObject(outlineItem)
                    if (node != null) {
                        node.reveal()
                    }
                }
            }
        }

        run()
	})

	action.validate = function(selection, sender) {
		return true
    }

    function showErrorAlert(message) {
        new Alert("GTD Plugin Error", message).show(null)
    }

    function urgencyFromDates(gs, target, red, critical) {
        if (critical != null && gs.now >= critical) {
            return urgencies.critical
        } else if (red != null && gs.now >= red) {
            return urgencies.pastDue
        } else if (target != null && gs.now >= target) {
            return urgencies.attention
        } else {
            return null
        }
    }

    return action
}();
_;

function getEnumValue(outlineItem, col) {
    let enumValue = outlineItem.valueForColumn(col)
    if (enumValue) {
        return enumValue.name
    } else {
        return null
    }
}

function setEnumValue(outlineItem, col, name) {
    if (name == null) {
        outlineItem.setValueForColumn(null, col)
    } else {
        let member = col.enumeration.memberNamed(name)
        if (member) {
            outlineItem.setValueForColumn(member, col)
        }
    }
}

function getStringValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return value.string
    } else {
        return ''
    }
}

function getNumericValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return +(value.toString())
    } else {
        return null
    }
}

function getCheckboxValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return value === State.Checked
    } else {
        return null
    }
}

function toggleNamedStyle(outlineItem, namedStyle, apply) {
    let applied = hasNamedStyle(outlineItem, namedStyle)
    if (applied != apply) {
        if (apply) {
            outlineItem.style.addNamedStyle(namedStyle)
        } else {
            outlineItem.style.removeNamedStyle(namedStyle)
        }
    }
}

function hasNamedStyle(outlineItem, namedStyle) {
    for (let ns of outlineItem.style.namedStyles) {
        if (ns === namedStyle) {
            return true
        }
    }
    return false
}

function ndays(n) {
    let c = new DateComponents()
    c.day = n
    return c
}

function minDate(a, b) {
    if (a == null) {
        return b
    } else if (b == null) {
        return a
    } else if (a <= b) {
        return a
    } else {
        return b
    }
}

function maxDate(a, b) {
    if (a == null) {
        return b
    } else if (b == null) {
        return a
    } else if (a >= b) {
        return a
    } else {
        return b
    }
}