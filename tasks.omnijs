/*{
	"type": "action",
	"targets": ["omnioutliner"],
	"author": "Andrey Tarantsov",
	"identifier": "com.tarantsov.automation.omniTasks",
	"version": "1.0",
	"description": "GTD done right",
	"label": "GTD",
	"shortLabel": "GTD"
}*/
var _ = function(){
    let calendar = Calendar.current

    const config = {
        // start days at 4am
        startOfDayHour: 4
    }

    const timeframes = {
        'unspecified': {
            isCommitted: false,
            isSchedulingCovered: false,
        },
        'Today': {
            isCommitted: false,
            isSchedulingCovered: true,
            shouldDeadlineDefaultToStartDay: true,
        },
        'Day': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 1,
            reservedDays: 1,
            redDays: 2,
            criticalDays: 4,
        },
        'Days': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 2,
            reservedDays: 2,
            redDays: 3,
            criticalDays: 5,
        },
        'Week': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 7,
            reservedDays: 2,
            redDays: 14,
            criticalDays: 21,
        },
        'Month': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 30,
            reservedDays: 5,
            redDays: 60,
            criticalDays: 90,
        },
        'Quarter': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 30 * 3,
            reservedDays: 30,
            redDays: 30 * 5,
            criticalDays: 30 * 7,
        },
        'Year': {
            isCommitted: true,
            isSchedulingCovered: true,
            dueDays: 365,
            reservedDays: 30 * 2,
            redDays: Math.floor(365 * 1.5),
            criticalDays: Math.floor(365 * 2),
        },
    }

    const behaviors = {
        'default': {
            name: 'default',
        },
        'root': {
            name: 'root',
            isContainer: true,
        },
        'Area': {
            name: 'Area',
            isContainer: true,
        },
        'backlog': {
            name: 'backlog',
            isContainer: true,
            shouldBeCollapsed: true,
        },
        'Inbox': {
            name: 'Inbox',
            isContainer: true,
        },
        'Idea': {
            name: 'Idea',
            isSchedulingCovered: true,
        },
        'Blocked': {
            name: 'Blocked',
            isSchedulingCovered: true,
        },
        'Waiting For': {
            name: 'Waiting For',
            isSchedulingCovered: true,
        },
        'Folder': {
            name: 'Folder',
            isContainer: false,
            isStyledAsFolder: true,
        },
        'Elephant': {
            name: 'Elephant',
            isContainer: true,
        },
    }

    const modes = {
        topLevel: {
            name: 'topLevel',
        },
        topLevelItem: {
            name: 'topLevelItem',
        },
        dailyItem: {
            name: 'dailyItem',
        },
        regular: {
            name: 'regular',
        },
    }

    const urgencies = {
        done: {
            name: 'done',
            isAttentionRequired: false,
            isProminencyRequired: false,
        },
        normal: {
            name: 'normal',
            isProminencyRequired: false,
            isAttentionRequired: false,
        },
        future: {
            name: 'future',
            futureStyle: true,
            isProminencyRequired: false,
            isAttentionRequired: false,
        },
        soon: {
            name: 'soon',
            isProminencyRequired: true,
            isAttentionRequired: false,
        },
        attention: {
            name: 'attention',
            attentionStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
        pastDue: {
            name: 'pastDue',
            dueStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
        critical: {
            name: 'critical',
            urgentStyle: true,
            isProminencyRequired: true,
            isAttentionRequired: true,
        },
    }

    const specials = {
        backlog: {
            name: 'backlog',
        }
    }

    const actionWords = `
        обсудить
    `.trim().split(/\s+/)

	const action = new PlugIn.Action(function(selection, sender){
        const document = selection.document
        const outline = document.outline

        const doneColumn = outline.columns.byTitle('D')
        const doneDateColumn = outline.columns.byTitle('Done')
        const typeColumn = outline.columns.byTitle('Type')
        const whenColumn = outline.columns.byTitle('When')
        const taskColumn = outline.columns.byTitle('Task')
        const deadlineColumn = outline.columns.byTitle('Deadline')
        const startColumn = outline.columns.byTitle('Start')
        const verboseColumn = outline.columns.byTitle('V')
        const reserveColumn = outline.columns.byTitle('Re')

        const now = new Date()
        const today = startOfDay(now)
        const tomorrow = startOfDay(addDays(today, 1))

        // TODO: Mon-Fri = till end of this week, Sat-Sun = till end of next week
        const planningHorizon = startOfDay(addDays(today, 7))

        console.clear()
        console.log(JSON.stringify({now, today, tomorrow}, null, 2))

        const folderStyle = requireNamedStyle('Heading 2')
        const urgentStyle = requireNamedStyle('Urgent')
        const attentionStyle = requireNamedStyle('Attention')
        const dueStyle = requireNamedStyle('Past Due')
        const futureStyle = requireNamedStyle('Future')
        const reviewStyle = requireNamedStyle('Review')
        const doneStyle = requireNamedStyle('Done')

        var pendingChanges = []
        var itemsToCollapse = []
        var itemsToReveal = []

        function loadItem(outlineItem) {
            let item = {
                outlineItem,

                typeColumnValue: getEnumValue(outlineItem, typeColumn),
                title: getStringValue(outlineItem, taskColumn),
                timeframeColumnValue: getEnumValue(outlineItem, whenColumn),
                isVerbose: (outlineItem.level === 0 || getCheckboxValue(outlineItem, verboseColumn)),
                isDone: getCheckboxValue(outlineItem, doneColumn),
                doneDate: outlineItem.valueForColumn(doneDateColumn),

                startDate: outlineItem.valueForColumn(startColumn),
                reservedDays: getNumericValue(outlineItem, reserveColumn),  // how much time you think this task will take
                deadline: outlineItem.valueForColumn(deadlineColumn),
                timeframe: timeframes.unspecified,
                behavior: behaviors.default,

                warnings: [],

                special: null,
            }

            if (item.title != null && item.title.toUpperCase() === "BACKLOG") {
                item.special = specials.backlog
            }

            if (item.timeframeColumnValue != null) {
                if (!timeframes.hasOwnProperty(item.timeframeColumnValue)) {
                    throw new Error(`unknown When ${item.timeframeColumnValue} in task: ${item.title}`)
                }
                item.timeframe = timeframes[item.timeframeColumnValue]
            }

            if (item.outlineItem.level === 0) {
                item.behavior = behaviors.root
            } else if (item.typeColumnValue != null) {
                if (!behaviors.hasOwnProperty(item.typeColumnValue)) {
                    throw new Error(`unknown Type ${item.typeColumnValue} in task: ${item.title}`)
                }
                item.behavior = behaviors[item.typeColumnValue]
            } else if (item.outlineItem.level === 1) {
                item.behavior = behaviors.Area
            } else if (item.title != null && item.title.toUpperCase() === "BACKLOG") {
                item.behavior = behaviors.backlog
            }

            return item
        }

        function processItem(outlineItem, mode, isUnderBacklog, backlogItem, atom, isSchedulingCoveredByParent, isNonNextAction, context) {
            let item = loadItem(outlineItem)

            item.childrenContext = {...context}

            if (atom == null && !item.behavior.isContainer) {
                atom = item.outlineItem
            }

            if (context.deadline) {
                if (item.deadline) {
                    if (item.deadline > context.deadline) {
                        item.warnings.push(`item item.deadline is later than ancestor's item.deadline`)
                    }
                } else {
                    item.deadline = context.deadline
                }
            }

            let isSchedulingCovered = isSchedulingCoveredByParent


            // backlog
            let backlogItemForChildren = backlogItem
            if (isBacklogItem(item.outlineItem)) {
                isUnderBacklog = true
                backlogItem = item.outlineItem
            } else if (item.outlineItem.children.length > 0) {
                item.outlineItem.children.forEach((child) => {
                    if (isBacklogItem(child)) {
                        backlogItemForChildren = child
                        // console.log(`Found backlog child ${getStringValue(child, taskColumn)} under ${item.title}`)
                    }
                })
            }

            let urgency = null, targetDate = null, redDate = null, criticalDate = null

            if (item.isDone) {
                urgency = urgencies.done
                isSchedulingCovered = true
            }
            if (atom != null && (item.behavior.isSchedulingCovered || item.timeframe.isSchedulingCovered)) {
                isSchedulingCovered = true
            }
            if (urgency == null && atom != null && item.startDate != null && item.startDate >= tomorrow) {
                urgency = urgencies.future
                isSchedulingCovered = true
            }
            if (urgency == null && mode === modes.dailyItem) {
                urgency = urgencies.normal
                isSchedulingCovered = true
            }

            toggleNamedStyle(item.outlineItem, folderStyle, item.behavior.isStyledAsFolder)
            toggleNamedStyle(item.outlineItem, doneStyle, item.isDone)
            if (item.isDone && item.doneDate == null) {
                item.outlineItem.setValueForColumn(now, doneDateColumn)
            } else if (!item.isDone && item.doneDate != null) {
                item.outlineItem.setValueForColumn(null, doneDateColumn)
            }

            let childMode = modes.regular
            if (item.title != null && item.title.toUpperCase() === "DAILY") {
                childMode = modes.dailyItem
            } else if (mode === modes.topLevel) {
                childMode = modes.topLevelItem
            }

            if (mode === modes.dailyItem) {
                if (item.startDate == null || item.startDate < today) {
                    item.outlineItem.setValueForColumn(today, startColumn)
                    item.startDate = today
                }
                if (item.startDate != null && item.startDate < today) {
                    resetChecked(item.outlineItem)
                }
                if (item.timeframe === timeframes.unspecified) {
                    item.timeframe = timeframes.Today
                }
            } else {
                if (item.timeframe.isCommitted && item.startDate == null) {
                    item.outlineItem.setValueForColumn(today, startColumn)
                    item.startDate = today
                }
            }

            if (item.timeframe.shouldDeadlineDefaultToStartDay && item.deadline == null && item.startDate != null) {
                item.deadline = startOfDay(item.startDate)
            }

            if (item.startDate != null) {
                let defaultReservedDays = (item.timeframe.isCommitted ? item.timeframe.reservedDays : 2)

                if (urgency == null && item.deadline) {
                    let deadlineReservedDays = (item.reservedDays == null ? defaultReservedDays : item.reservedDays)
                    targetDate = startOfDay(addDays(item.deadline, -deadlineReservedDays))
                    redDate = startOfDay(item.deadline)
                    criticalDate = startOfDay(addDays(item.deadline, 1))
                    urgency = urgencyFromDates(targetDate, redDate, criticalDate)
                }
                if (urgency == null && item.timeframe.isCommitted) {
                    let dueDate = startOfDay(addDays(item.startDate, item.timeframe.dueDays))
                    targetDate = startOfDay(addDays(dueDate, -defaultReservedDays))
                    redDate = startOfDay(addDays(item.startDate, item.timeframe.redDays))
                    criticalDate = startOfDay(addDays(dueDate, item.timeframe.criticalDays))
                    urgency = urgencyFromDates(targetDate, redDate, criticalDate)
                }
            }

            if (urgency == null && targetDate != null && targetDate < planningHorizon) {
                urgency = urgencies.soon
            }

            if (urgency == null) {
                urgency = urgencies.normal
            }

            toggleNamedStyle(item.outlineItem, futureStyle, urgency.futureStyle)
            toggleNamedStyle(item.outlineItem, attentionStyle, urgency.attentionStyle)
            toggleNamedStyle(item.outlineItem, dueStyle, urgency.dueStyle)
            toggleNamedStyle(item.outlineItem, urgentStyle, urgency.urgentStyle)

            let isAttentionRequiredByDescendants = false
            let isReviewRequiredByDescendants = false
            let isProminencyRequiredByDescendants = false

            // *************** CHILDREN ***************
            item.childrenContext.deadline = item.deadline
            item.childrenContext.reservedDays = item.reservedDays
            if (item.outlineItem.children.length > 0) {
                let childSchedulingCovered = isSchedulingCovered
                let isFirstChild = true
                item.outlineItem.children.forEach((child) => {
                    let isChildNonNextAction = (atom != null && !isFirstChild)
                    let rv = processItem(child, childMode, isUnderBacklog, backlogItemForChildren, atom, childSchedulingCovered, isChildNonNextAction, item.childrenContext)
                    if (atom != null) {
                        if (isFirstChild && !isSchedulingCovered && rv.isSchedulingCovered) {
                            isSchedulingCovered = true
                        }
                        childSchedulingCovered = true
                    }
                    if (rv.isReviewRequiredInSubtree) {
                        isReviewRequiredByDescendants = true
                    }
                    if (rv.isAttentionRequiredInSubtree) {
                        isAttentionRequiredByDescendants = true
                    }
                    if (rv.isProminencyRequiredInSubtree) {
                        isProminencyRequiredByDescendants = true
                    }
                    isFirstChild = false
                })
            }

            let isReviewRequired = false
            if (atom != null && !isSchedulingCovered) {
                isReviewRequired = true
            }

            let isAttentionRequired = (isReviewRequired || urgency.isAttentionRequired)
            let isAttentionRequiredInSubtree = isAttentionRequired || isAttentionRequiredByDescendants
            let isProminencyRequired = (urgency.isProminencyRequired || isAttentionRequiredInSubtree)

            let isReviewRequiredInSubtree = isReviewRequired || isReviewRequiredByDescendants

            let isProminencyRequiredInSubtree = isProminencyRequired || isProminencyRequiredByDescendants

            let shouldBeCollapsed = !!item.behavior.shouldBeCollapsed
            if (item.outlineItem === atom) {
                toggleNamedStyle(item.outlineItem, reviewStyle, isReviewRequiredInSubtree)

                let shouldBeInBacklog = !isProminencyRequiredInSubtree
                if (backlogItem != null) {
                    if (shouldBeInBacklog && !isUnderBacklog) {
                        // move to backlog
                        pendingChanges.push(function() {
                            console.log(`moving to backlog: ${item.title}`)
                            outline.moveItems([item.outlineItem], backlogItem.end)
                        })
                    } else if (!shouldBeInBacklog && isUnderBacklog) {
                        // move out of backlog
                        pendingChanges.push(function() {
                            console.log(`moving out of backlog: ${item.title}`)
                            outline.moveItems([item.outlineItem], backlogItem.before)
                        })
                    }
                }

                shouldBeCollapsed = (shouldBeInBacklog || !isAttentionRequiredByDescendants)
            } else {
                toggleNamedStyle(item.outlineItem, reviewStyle, isReviewRequired)

                if (atom != null) {
                    let levelInAtom = item.outlineItem.level - atom.level
                    shouldBeCollapsed = (levelInAtom == 1 && !isAttentionRequiredByDescendants)
                }
            }

            if (isAttentionRequired) {
                itemsToReveal.push(item.outlineItem)
            } else if (shouldBeCollapsed) {
                itemsToCollapse.push(item.outlineItem)
            }

            let rv = {
                isSchedulingCovered,
                isReviewRequiredInSubtree,
                isAttentionRequiredInSubtree,
                isProminencyRequiredInSubtree,
            }

            if (item.isVerbose) {
                let itemInfo = {
                    item,
                    mode: mode.name,
                    urgency: urgency.name, targetDate, redDate, criticalDate,
                    atom: (atom ? (getStringValue(atom, taskColumn) || '<untitled>') : null),
                    isSchedulingCovered, isSchedulingCoveredByParent,
                    isReviewRequired, isReviewRequiredByDescendants, isReviewRequiredInSubtree,
                    isAttentionRequired, isAttentionRequiredByDescendants, isAttentionRequiredInSubtree,
                    isProminencyRequired, isProminencyRequiredByDescendants, isProminencyRequiredInSubtree,
                }
                console.log(JSON.stringify(itemInfo, null, 2))
                    // console.log(`title = ${item.title}, type = ${item.typeColumnValue}, mode = ${mode.name}, item.deadline = ${item.deadline}, committedAt = ${item.startDate},
                    //  urgency = ${urgency.name}, targetDate = ${targetDate}, redDate = ${redDate}, criticalDate = ${criticalDate},
                    // atom = ${atom}, isSchedulingCovered = ${isSchedulingCovered}, isSchedulingCoveredByParent = ${isSchedulingCoveredByParent},
                    //  isReviewRequired = ${isReviewRequired}, rv = ${JSON.stringify(rv)}`)
            }

            return rv
        }

        function resetChecked(outlineItem) {
            outlineItem.setValueForColumn(State.Unchecked, doneColumn)
        }

        function requireNamedStyle(name) {
            const style = outline.namedStyles.byName(name)
            if (style == null) {
                throw new Error("Cannot find named style " + name)
            }
            return style
        }

        function addDays(date, n) {
            return calendar.dateByAddingDateComponents(date, ndays(n))
        }

        function isBacklogItem(outlineItem) {
            let title = getStringValue(outlineItem, taskColumn)
            return (title != null && title.toUpperCase() === "BACKLOG")
        }

        function urgencyFromDates(target, red, critical) {
            if (critical != null && now >= critical) {
                return urgencies.critical
            } else if (red != null && now >= red) {
                return urgencies.pastDue
            } else if (target != null && now >= target) {
                return urgencies.attention
            } else {
                return null
            }
        }

        processItem(outline.rootItem, modes.topLevel, false, null, null, false, false, {})

        for (let change of pendingChanges) {
            change()
        }
        for (let outlineItem of itemsToCollapse) {
            for (let editor of document.editors) {
                let node = editor.nodeForObject(outlineItem)
                if (node != null && node.isExpanded && node.canCollapse) {
                    node.collapse()
                }
            }
        }
        for (let outlineItem of itemsToReveal) {
            for (let editor of document.editors) {
                let node = editor.nodeForObject(outlineItem)
                if (node != null) {
                    node.reveal()
                }
            }
        }
	})

	action.validate = function(selection, sender) {
		return true
    }

    function startOfDay(date) {
        let c = calendar.dateComponentsFromDate(date)
        c.hour = config.startOfDayHour
        c.minute = 0
        c.second = 0
        c.nanosecond = 0
        let d = calendar.dateFromDateComponents(c)
        if (d == null) {
            let c = new DateComponents()
            c.hours = config.startOfDayHour
            d = calendar.dateByAddingDateComponents(calendar.startOfDay(date), c)
        }
        return d
    }

    function showErrorAlert(message) {
        new Alert("GTD Plugin Error", message).show(null)
    }

    return action
}();
_;

function getEnumValue(outlineItem, col) {
    let enumValue = outlineItem.valueForColumn(col)
    if (enumValue) {
        return enumValue.name
    } else {
        return null
    }
}

function setEnumValue(outlineItem, col, name) {
    if (name == null) {
        outlineItem.setValueForColumn(null, col)
    } else {
        let member = col.enumeration.memberNamed(name)
        if (member) {
            outlineItem.setValueForColumn(member, col)
        }
    }
}

function getStringValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return value.string
    } else {
        return ''
    }
}

function getNumericValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return +(value.toString())
    } else {
        return null
    }
}

function getCheckboxValue(outlineItem, col) {
    let value = outlineItem.valueForColumn(col)
    if (value) {
        return value === State.Checked
    } else {
        return null
    }
}

function toggleNamedStyle(outlineItem, namedStyle, apply) {
    let applied = hasNamedStyle(outlineItem, namedStyle)
    if (applied != apply) {
        if (apply) {
            outlineItem.style.addNamedStyle(namedStyle)
        } else {
            outlineItem.style.removeNamedStyle(namedStyle)
        }
    }
}

function hasNamedStyle(outlineItem, namedStyle) {
    for (let ns of outlineItem.style.namedStyles) {
        if (ns === namedStyle) {
            return true
        }
    }
    return false
}

function ndays(n) {
    let c = new DateComponents()
    c.day = n
    return c
}

function isNextAction(atom, outlineItem) {
    if (atom == null) {
        return false
    }
    if (outlineItem === atom) {
        return true
    }
    while (outlineItem != null && outlineItem !== atom) {
        if (outlineItem.index > 0) {
            return false
        }
        outlineItem = outlineItem.parent
    }
    return false
}

function minDate(a, b) {
    if (a == null) {
        return b
    } else if (b == null) {
        return a
    } else if (a <= b) {
        return a
    } else {
        return b
    }
}

function maxDate(a, b) {
    if (a == null) {
        return b
    } else if (b == null) {
        return a
    } else if (a >= b) {
        return a
    } else {
        return b
    }
}